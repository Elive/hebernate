#!/bin/bash
SOURCE="$0"
source /usr/lib/elive-tools/functions
REPORTS="1"
el_make_environment
. gettext.sh
TEXTDOMAIN="hebernate"
export TEXTDOMAIN

# Lock system (good one) {{{
lockfile="/tmp/.$(basename $0)-${USER}.lock"

exit_ok(){
    rm -f "$lockfile"
}
exit_error(){
    rm -f "$lockfile"
}

if [[ -r "$lockfile" ]] ; then
    PROCCESS="$(cat $lockfile)"
else
    PROCCESS=" "
fi
if (ps up $PROCCESS) 1>/dev/null 2>&1 ; then
    el_error "$(basename $0) already running"
    exit
else
    echo $$ > "$lockfile"
fi

# traps needs to be after the lock verification, in order to not remove it when we are already running
trap "exit_ok" EXIT
trap "exit_error" 1 3 5 6 14 15 ERR TERM

# SET the lock file
echo "$$" > "$lockfile"


# end lock system }}}

usage(){
    # Usage
    if [[ -z "${1}" ]] ; then
        echo -e "Usage: $(basename $BASH_SOURCE) suspend|hibernate|stop|shutdown|reboot|lock"
        echo -e ""
        echo -e "Notes: 'stop' means suspending the system and hibernate it after a while (useful for when you don't know how much time you will stop the system, this should be the default stop of the system)"
        echo -e ""
        exit 1
    fi
}

guitool(){
    local mode message
    mode="$1"
    shift
    message="$1"
    shift

    case "$mode" in
        question)
            if [[ -n "$DISPLAY" ]] ; then
                if $guitool --question --text="$message" ; then
                    return 0
                else
                    return 1
                fi
            else
                if el_confirm "$message" ; then
                    return 0
                else
                    return 1
                fi
            fi
            ;;
        warning)
            if [[ -n "$DISPLAY" ]] ; then
                $guitool --warning --text="$message"
            else
                el_warning "$message"
            fi
            ;;
        error)
            if [[ -n "$DISPLAY" ]] ; then
                $guitool --error --text="$message"
            else
                el_error "$message"
            fi
            ;;
        info)
            if [[ -n "$DISPLAY" ]] ; then
                $guitool --info --text="$message"
            else
                el_info "$message"
            fi
            ;;
        *)
            el_error "unknown action for $FUNCNAME ($mode)"
            ;;
    esac
}

apt_dpkg_wait(){
    local is_waiting i
    i=0

    tput sc
    while fuser /var/lib/dpkg/lock /var/lib/apt/lists/lock  >/dev/null 2>&1 ; do
        case $(($i % 4)) in
            0 ) j="-" ;;
            1 ) j="\\" ;;
            2 ) j="|" ;;
            3 ) j="/" ;;
        esac
        tput rc
        echo -en "\r[$j] Waiting for other software managers to finish..."
        is_waiting=1

        LC_ALL=C  sleep 0.5
        ((i=i+1))
    done

    # make sure that dpkg/apt still not running
    if ((is_waiting)) ; then
        unset is_waiting
        LC_ALL=C  sleep 3
        # recursively call it again
        $FUNCNAME
    fi
}


check_and_inform_when_processes_running(){
    # pre {{{
    local watcher

    local message_wait_processes_title
    message_wait_processes_title="$( printf "$( eval_gettext "Waiting for processes to finish" )" "" )"

    local message_wait_processes_generic
    message_wait_processes_generic="$( printf "$( eval_gettext "Your computer will shutdown after some remaining processes finish" )" "" )"


    # - pre }}}

    # kill possible useless ones {{{
    for i in tumblerd mpg123 mplayer smplayer vlc rage_thumb
    do
        killall "$i"     1>/dev/null 2>&1
        killall -9 "$i"  1>/dev/null 2>&1
    done
    # - kill possible useless ones }}}

    # TODO: temporal checks: these are meant to be other poweroff processes, we should simply exit in case that they are (already) running?
    if \
        pidof -x 'xfce4-power-manager' 1>/dev/null 2>&1 || \
        pidof -x 'mate-power-manager' 1>/dev/null 2>&1 || \
        pidof -x 'dalston-power-applet' 1>/dev/null 2>&1 || \
        pidof -x 'gnome-power-manager' 1>/dev/null 2>&1 || \
        pidof -x 'kpowersave' 1>/dev/null 2>&1 || \
        pidof -x 'guidance-power-manager.py' 1>/dev/null 2>&1 ; then
        # just report, because we don't know if we should ingore them or not
        el_warning "another poweroff system running?"

        #( guitool warning "Seems like we have other poweroff services already running?"  & )
    fi


    # apt / dpkg processes
    if fuser /var/lib/dpkg/lock /var/lib/apt/lists/lock  1>/dev/null 2>&1 ; then
        local message_wait_processes
        message_wait_processes="$( printf "$( eval_gettext "Some package processes are running, probably an upgrade of the system. Your computer shutdown will be executed after these processes are finished." )" "" )"

        # seems like desktop is off, so we cannot send a notify message?
        #el_notify_user_important "$message_wait_processes_title" "$message_wait_processes"
        ( guitool info "$message_wait_processes" & )
        #el_speak_text "waiting packages process to finish"

        # and wait before to proceed:
        apt_dpkg_wait
    fi

    # other possible X processes:
    for watcher in elive-upgrader mkdeb apt apt-get dpkg fsck sync umount
    do
        if ps aux | grep -v grep | grep -v "$$" | grep -v "$(basename $0) $watcher" | grep -vE "(vim|gvim|emacs|scite|geany).*${watcher}" | grep -qE "([[:digit:]] ${watcher} |[[:digit:]] ${watcher}$|[[:digit:]] .*bin/${watcher} |[[:digit:]] .*bin/${watcher}$)" ; then

            local message_waitingfor
            message_waitingfor="$( printf "$( eval_gettext "Some processes are still running. Waiting for them to finish:" )" "" )"

            ( guitool info "${message_waitingfor} $watcher" & )

            #el_speak_text "Please wait, some processes are still running. Wating for $watcher"

            # TODO: temporal report:
            el_warning "$(basename $0): waiting for process: $watcher"
            #log_msg... ?

            #el_notify_user_important "$message_wait_processes_title" "${message_wait_processes_generic}:\n\n$watcher"
            ( guitool info "${message_wait_processes_title}. ${message_wait_processes_generic}:\n\n$watcher" & )

            waitfor $watcher
        fi
    done

}

check_if_already_shutdown_process(){
    if \
        pidof -x '/sbin/pm-suspend' 1>/dev/null 2>&1 || \
        pidof -x '/sbin/pm-suspend-hybrid' 1>/dev/null 2>&1 || \
        pidof -x '/sbin/pm-hibernate' 1>/dev/null 2>&1 || \
        pidof -x '/usr/sbin/pm-suspend' 1>/dev/null 2>&1 || \
        pidof -x '/usr/sbin/pm-suspend-hybrid' 1>/dev/null 2>&1 || \
        pidof -x '/usr/sbin/pm-hibernate' 1>/dev/null 2>&1 || \
        pidof -x '/sbin/shutdown' 1>/dev/null 2>&1 || \
        pidof -x '/sbin/reboot' 1>/dev/null 2>&1 || \
        pidof -x '/usr/sbin/shutdown' 1>/dev/null 2>&1 || \
        pidof -x '/usr/sbin/reboot' 1>/dev/null 2>&1 || \
        /sbin/runlevel | grep -qs "[06]" ; then

        return 1
    else
        return 0
    fi
}

inform_if_errors(){
    local lines

    for i in 1 2 3 4 5
    do
        lines="$( dmesg | tail -n 300 )"
        lines_tmp="$( echo "$lines" | grep -i error | grep -i sector )"

        # HD data loss?
        if [[ "$lines_tmp" -gt "3" ]] ; then
            guitool warning "$( eval_gettext "The following error messages have been found in your system. Inspect them in more detail to see if you really have an issue. If these features produce any issues or data loss, you should stop using this feature or try it with a different kernel version. Not doing so may cause data loss." )\n\n$( echo "${lines}" | sort -u )"
            el_warning "possible data loss recovering from suspension / hibernation: $( echo "$lines" | tail -10 )"

            break
        fi

        # vbox errors:
        lines_tmp="$( echo "$lines" | grep -iE "(vminfo.*error|VERR_NOT_SUPPORTED|error.*virtualbox)" )"
        if [[ "$lines_tmp" -gt "3" ]] ; then
            guitool warning "$( eval_gettext "Please check your system logs using DMESG. It is possible that your virtual environment doesn't supports well the suspension or hibernation features." )"
            #el_warning "possible vbox errors: $( echo "$lines" | tail -10 )"
        fi

        lines_tmp="$( echo "$lines" | grep -iE "\[ cut here \]" )"
        if [[ "$lines_tmp" -ge "1" ]] ; then
            guitool warning "$( eval_gettext "Please check your system logs using DMESG. It is possible that there's some issues after recovering your computer." )"
            el_warning "possible backtrace founds: $( echo "$lines" | tail -30 )"
        fi

        sleep 3
    done
}

do_desktop_lock(){
    # e16
    if [[ -n "$EROOT" ]] ; then
        if [[ -x "$(which i3lock-fancy)" ]] ; then
            ( sleep 6 ; xset dpms force off ; )
            i3lock-fancy -g

            waitfor i3lock-fancy && xset dpms 0 0 0
        else
            if [[ -x "$(which i3lock)" ]] ; then
                ( sleep 6 ; xset dpms force off ; )
                i3lock -f -c 000000

                waitfor i3lock && xset dpms 0 0 0
            fi
        fi
    else
        if [[ -n "$E_START" ]] ; then
            #enlightenment_remove -lock
            enlightenment_remove -desktop-lock
        fi
    fi
}

do_fallback(){
    case "$1" in
        reboot)
            if ! /sbin/reboot ; then
                if el_check_sudo_automated ; then
                    el_sudo /sbin/reboot
                else
                    #gksu /sbin/reboot
                    /sbin/reboot
                fi
            fi
            ;;
        shutdown)
            if ! /sbin/poweroff ; then
                if el_check_sudo_automated ; then
                    el_sudo /sbin/poweroff
                else
                    #gksu /sbin/poweroff
                    /sbin/poweroff
                fi
            fi
            ;;
        hibernate|suspend-then-hibernate)
            if el_check_sudo_automated ; then
                el_sudo /sbin/pm-hibernate
            else
                # seems like we should not need su
                #gksu /sbin/hebernate "$1"
                /sbin/pm-hibernate
            fi
            ;;
        suspend)
            if el_check_sudo_automated ; then
                el_sudo /sbin/pm-suspend
            else
                # seems like we should not need su
                #gksu /sbin/hebernate "$1"
                /sbin/pm-suspend
            fi
            ;;
    esac
}

do_action(){
    # pre {{{
    local action

    action="$1"
    shift

    # - pre }}}
    # checks {{{
    if ! check_if_already_shutdown_process ; then
        guitool info "$( eval_gettext "Ignoring action, system is already shuting down" )"
        exit
    fi


    # live mode?
    local message_live_disabled
    message_live_disabled="$( printf "$( eval_gettext "You cannot perform a suspension of your computer while you are using Elive in Live mode. You need to install Elive in your computer to use this feature." )" "" )"

    if grep -q "boot=live" /proc/cmdline ; then
        case "$action" in
            suspend|hibernate|suspend-then-hibernate)
                el_notify_user_important "Live mode detected" "$message_live_disabled"
                exit
                ;;
        esac
    fi

    # wait for possible proccesses running
    case "$action" in
        suspend|hibernate|suspend-then-hibernate|lock)
            true
            ;;
        shutdown|poweroff|reboot)
            check_and_inform_when_processes_running
            ;;
        *)
            el_warning "not implemented $action"
            ;;
    esac

    # check and infor for possible things required
    case "$action" in
        hibernate)
            # check if we have a resume configuration
            if ! grep -qsE "LINUX_DEFAULT.*resume=" /etc/default/grub ; then
                guitool error "$( eval_gettext "Your grub configuration doesn't include the swap space where to perform hibernation. If you want to have hibernation you should reinstall Elive and add a swap partition." )"
                exit
            fi
            # check for using swap space:
            if [[ "$( LC_ALL="$EL_LC_EN" free -m | grep -i "^Swap:" | awk '{print $2}' )" = 0 ]] ; then
                guitool warning "$( eval_gettext "It seems like you are not using a swap space, which is required to hibernate your computer. If hibernation doesn't work, you should reinstall Elive and add a swap partition to use this feature." )"
                exit
            fi
            ;;
    esac

    # - checks }}}
    # run
    sync

    if ((is_systemd)) ; then
        if systemctl "$action" 2>>"$logs_error" ; then
            # all good, exit
            #exit 0
            true
        else
            # maybe with sudo?
            if el_check_sudo_automated ; then
                if el_sudo systemctl "$action" 2>>"$logs_error" ; then
                    # all good, exit
                    #exit 0
                    true
                else
                    is_failed=1
                    el_warning "failed to run: systemctl '$action' (sudo): $(cat "$logs_error" )"
                fi
            else
                is_failed=1
                el_warning "no privileges for el_sudo, implement a gksu feature instead? (attempting $action):\n$(cat "$logs_error" )"
            fi
        fi
    else
        do_fallback "$action"
    fi

    # errors? {{{
    # show errors if any
    if ((is_failed)) && [[ -s "$logs_error" ]] ; then
        guitool error "$( cat "$logs_error" | uniq )"
    fi


    # - errors? }}}

    #
    # BACK from suspsension
    #

    sync

    case "$action" in
        suspend|hibernate|suspend-then-hibernate)
            # check for errors
            inform_if_errors &

            # play audio of system restored
            hour="$(date +%k)"
            if [[ "${hour}" -lt "21" ]] && [[ "$hour" -gt "8" ]] ; then
                soundfile="/usr/share/sounds/elive/system-restored.mp3"
                precache "$soundfile" 2>/dev/null
                if [[ -x "$(which mplayer)" ]] ; then
                    ( timeout 30 mplayer -noconfig all -really-quiet "$soundfile" & )
                else
                    el_speak_text "welcome back to ailive"
                fi
            fi

            # hibernation seems to require an e16 restart, at least in vbox:
            #if [[ "$action" = "hibernate" ]] && [[ -n "$EROOT" ]] ; then
                #eesh restart
            #fi
            if [[ "$action" = "hibernate" ]] && el_check_sudo_automated ; then
                # reload swap if possible, to have the desktop resonsive
                sleep 5 ; sync
                el_sudo swapoff -a 1>/dev/null 2>&1
                el_sudo swapon -a 1>/dev/null 2>&1
            fi
            ;;
    esac


}



main(){
    # pre {{{
    local arg

    if [[ -z "$1" ]] ; then
        usage
    fi

    logs_error="$( mktemp )"
    el_add_on_exit  rm -f "$logs_error"

    if pidof systemd 1>/dev/null 2>&1 ; then
        is_systemd=1
    fi

    el_config_get

    # }}}

    for arg in "$@"
    do
        case "$arg" in
            suspend)
                is_suspend=1
                do_action "suspend"
                ;;
            hibernate)
                is_hibernate=1
                do_action "hibernate"
                ;;
            shutdown|poweroff|halt)
                is_shutdown=1
                do_action "poweroff"
                ;;
            reboot)
                is_reboot=1
                do_action "reboot"
                ;;
            lock)
                is_lock=1
                do_desktop_lock
                ;;
            stop)
                is_stop=1
                do_action "suspend-then-hibernate"
                ;;
            *)
                usage
                ;;
        esac
    done


    wait

}

#
#  MAIN
#
main "$@"

# vim: set foldmethod=marker :
